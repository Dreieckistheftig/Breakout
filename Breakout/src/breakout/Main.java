package breakout;

import javax.swing.JFrame;
import breakout.controller.Controller;
import breakout.model.GameWorld;
import breakout.view.LightHouseView;
import breakout.view.LocalView;

/**
 * The retro arcade game BREAKOUT made with the MVC pattern.
 * 
 * The model holds all statuses and values while the controller contains a mouse
 * and key listener to enable the bar control for the user. The views are for
 * different displays, for example the device to play on and the 14x28 pixels
 * highrise-building, and are updated regularly.
 * 
 * The Main class starts the game by initializing the Model class with the
 * correct display resolutions, loading the views and starting the Controller
 * class with the listeners. The model class works with objects of the Ball,
 * Bricks and the Paddle. This pattern makes it possible for more than one
 * person to effectively work simultaneously on the game development and
 * abstract the processes of the program.
 * 
 * The LightHouseView gets the data out of the model and prints it with
 * 2D-Objects on a BufferedImage, which is then read pixel-by-pixel to fill the
 * Array for the LightHouse-API.
 * 
 * The LocalView works in a quite similar way. It uses a JFrame to display the
 * painted objects. Because of the initial resolution of 28*14px for the
 * LightHouse we use a factor to upscale the model.
 * 
 * We could have used a superclass for the objects, because all of them use at
 * least variables for x,y-positioning, but due to the bit-by-bit
 * development-process we forgot about this.
 * 
 * To start the game you must press a direction key.
 * The collision-check for bricks with multiple lives is not perfect.
 * 
 * Order of tasks:
 * 
 * 1) Writing the Model class and creating a "ball" point which moves and
 * bounces of all window borders. The bounce aims a physically logical
 * direction. Important: measuring the time for a constant FPS rate.
 * 
 * 2) Writing of the View class and a subclass to display the game process in an
 * applet on the PC.
 * 
 * 3) Writing of the Controller class which enables user input via mouse or
 * direction keys.
 * 
 * 4) Creating bar coordinates in the model an make them changeable by the user
 * input. The bar is counted by the ball as border to bounce of.
 * 
 * 5) Ground border is changed to GAME OVER and new Game initialization.
 * 
 * The author indications of the class Javadocs are autogenerated and not absolute.
 */
public class Main {
	public static void main(String[] args) {
		// Initialize a new GameWorld (model) with a resolution of 28px width and 14px
		// height.
		GameWorld gw = new GameWorld(28, 14);

		// Initialize a new LocalView (view) which we will put on the JFrame constructed
		// next
		LocalView view = new LocalView(gw);

		// Constructing a new JFrame to show the game locally
		JFrame vFrame = createFrame("Example", view);

		// Initialize the KeyListener and MouseListener
		new Controller(gw, vFrame, view);

		// Initialize a new LightHouseView (view) to show the game on the LightHouse
		LightHouseView lhView = new LightHouseView(gw, 28, 14, "DoubleAA", "API-TOK_X8jH-YrnU-bZ18-JBHt-35DL");
		// Save the current time in nano-seconds
		long lastTime = System.nanoTime();

		// Try connecting to the actual lighthouse
		try {
			if (!lhView.getLd().isConnected()) {
				lhView.getLd().connect();
			}
		} catch (Exception e) {
		}

		// Update the views
		while (true) {
			long now = System.nanoTime();

			// Updating the GameWorld by giving the commenced time to scale the movement
			gw.update((now - lastTime) / 1e9);
			lastTime = now;

			// Update the local view
			view.repaint();

			// Update the lighthouse view if connected
			try {
				if (lhView.getLd().isConnected()) {
					lhView.render();
				}
			} catch (Exception e) {
			}

			// Sleep for 10 milliseconds
			try {
				Thread.sleep(10);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Creates and fills a JFrame.
	 * 
	 * @param name
	 *            The Frame title.
	 * @param view
	 *            The view to be displayed.
	 * @return The filled JFrame.
	 */
	private static JFrame createFrame(String name, LocalView view) {
		JFrame vFrame = new JFrame(name);
		vFrame.add(view);
		vFrame.pack();
		vFrame.setResizable(false);
		vFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		vFrame.setLocationRelativeTo(null);
		vFrame.setVisible(true);
		return vFrame;
	}
}
