package breakout.view;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;

import breakout.model.Ball;
import breakout.model.GameWorld;
import de.cau.infprogoo.lighthouse.LighthouseDisplay;

/**
 * View class for the LightHouse.
 * 
 * @author armin
 *
 */
public class LightHouseView {

	private final GameWorld gw;
	private final LighthouseDisplay ld;
	private final byte[] backbuffer;

	private BufferedImage image;

	/**
	 * Constructor.
	 * 
	 * @param gw
	 *            GameWorld, which should be used.
	 * @param dW
	 *            Width of the view.
	 * @param dH
	 *            Height of the view.
	 * @param username
	 *            Username for the LightHouse-API.
	 * @param apitoken
	 *            API-Token for the LightHouse-API.
	 */
	// TODO read the Height and Width from the specified GameWorld
	public LightHouseView(GameWorld gw, int dW, int dH, String username, String apitoken) {
		this.gw = gw;
		ld = new LighthouseDisplay(username, apitoken);
		// We will use a BufferedImage to draw the view. It will have the size of the
		// GameWorld. The Array for the LightHouse will be generated by reading the
		// pixels.
		image = new BufferedImage(dW, dH, BufferedImage.TYPE_INT_RGB);
		backbuffer = new byte[dW * dH * 3];
	}

	/**
	 * Update the local BufferedImage by painting it all black and the adding the
	 * ball.
	 */
	private void updateImage() {
		// Convert image to Graphics2D
		Graphics2D g = (Graphics2D) image.getGraphics();

		// Use AntiAliasing to be able to show the ball more precisely.
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		// Komplettes Display schwarz, damit nur die aktuelle Position des Balls
		// angezeigt wird.
		g.setColor(Color.BLACK);
		g.fillRect(0, 0, image.getWidth(), image.getHeight());

		Ball ball = gw.ball;

		g.setColor(Color.RED);
		// Draw ball on the image.
		Ellipse2D.Double ballS = new Ellipse2D.Double(ball.x, ball.y, ball.r * 2, ball.r * 2);
		g.fill(ballS);

		g.dispose();

	}

	public void render() throws Exception {
		updateImage();

		// Read the pixels of the BufferedImage, split them up in the 3 (4 with alpha
		// channel) components and adding them to the array we want to send to the
		// LightHouse.
		int index = 0;
		for (int y = 0; y < image.getHeight(); y++) {
			for (int x = 0; x < image.getWidth(); x++) {
				// argb -> [8a, 8r, 8g, 8b]
				int argb = image.getRGB(x, y);
				// byte b = (byte)argb;
				// byte g = (byte)(argb >> 8);
				// byte r = (byte)(argb >> 16);
				backbuffer[index++] = (byte) (argb >> 16);
				backbuffer[index++] = (byte) (argb >> 8);
				backbuffer[index++] = (byte) (argb);
			}
		}

		if (!ld.isConnected()) {
			ld.connect();
		}

		ld.send(backbuffer);
	}
}
